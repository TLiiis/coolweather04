
一开始出错：
2.1.1）实践出错，刚开始的想法是直接一直向服务器发送请求然后拿到所有的数据，但是发现这样不行
                因为有时候会连接不上不上服务器，或者说丢包这种行为。而如果再次获取然后存储到数据库中
                因为id是auto_increment的，那么再次获取到会直接递增导致重复现象（当然可能设置不递增
                就可以解决这个问题，但是其实这不是个好的解决方案）。但是发现其实34个省份是可以拿到的
                参考郭霖大神的做法，就是先获取到34个省份，然后展示在listView上面，然后点击某个省份在
                向服务器发送请求获取。

----------------------------------------------------------------------------------------------------

功能：
    1、可以拿到所有的省市县数据，可以顺着来，也可以倒着来
    2、点击某个城市，可以拿到这个城市的天气数据，展示给用户看
    3、用户由没有打开到打开这个app时，会自动展示上次访问的城市的数据
    4、如果程序没有关闭，后台在间隔某个时间段自动更新
    5、用户下拉可以刷新

功能1.1 ---- 拿到省份数据概述：

ui部分：首先我们是想让这个省市县数据展示在可以拉出来的那个布局上面，需要用到material design中的drawerLayout布局。
然后我们让这个drawerLayout里面嵌套一个recyclerView，因为我们获取的省市县数据，我们需要将它们放在一个list上面，
然后展示出来。

代码部分：
    现在右边就可以拉出来的了，那么此时就是需要有数据在上面的，其实也就是给这个recyclerView设置适配器adapter了
    我们就是简单展示一个名字就行了，于是给展示在上面的view也是简单写了一个只带有textView和横线的一个xml布局文件。

    而获取的数据需要就是向服务器获取了，我们采用了okHttp的方式向服务器发送请求，并且因为它经常要用，我们就把它设置
    为工具类，传入address请求地址和Callback参数（回调，里面有服务器返回的数据）。这里需要注意，因为我们是耗时操作，
    所以我们是开启了一个线程的，在这个线程中发送请求，并且回调方法中也是在线程当中的。如果需要更新ui的操作，那么是
    在主线程当中才能进行的，因此我们在此处是创建了一个Handler，然后利用Handler将消息发送出去的。然后在Handler的handlerMessage当中
    更新的ui。

    但是，在编写的时候，我们为了能够用户一打开拉开就可以看到这个列表，于是我们是在MainActivity里面编写的，在MainActivity初始化的时候
    也就是onCreate方法执行的时候我们就将这个列表上面的数据展示出来，也就是向服务器发送请求然后获取数据然后进行解析然后展示在上面。

    但是注意，当我们需要重复利用这个相同不变的数据的时候，应该将数据存放在SQLite数据里面，然后从数据库里面查找出来，数据库当中找不到
    我们在联网获取，数据库查找因为东西少，所以很快而且不用流量。于是我们先是从数据库里面获取，获取不到才联网查询。这里是第一次获取，那么
    就是需要联网查询了肯定，查询之后我们是将得到的数据存储在数据库里面，然后在从数据库里面找出来放在list上面----------->此处疑问？能不能
    直接将查找到的数据放到列表上面，而不用在去查询，这样也快一些。也是可以的，但是好像也没有快多少的……因此其实数据少查询快。

    然后注意，联网操作时为了不让用户乱点击其它的东西影响运行，我们采用了弹出一个progressBar来屏蔽用户的相关操作。然后记得要调用dismiss方法
    来解除它，也就是联网结果返回后，成功然后更新完ui解除掉，失败的话就在onFail方法那里解除掉，然后弹出一个Toast让用户重新获取。

功能1.2 ---- 拿到城市和县级数据概述：
    现在recyclerView就是有省份的数据了，那么我们需要点击某一个条目拿到这个省份下的所有城市数据，然后点击城市拿到这个城市下所有的县级数据。
    点击县级数据拿到这个县的天气数据。那么我们如何知道点击的省份的列表还是城市的列表还是县级的列表呢？------->此时就要做标记了，在这个列表
    上面展示的是省份数据的时候，我们标记selectedState为省份类别，为城市的时候标记为城市类别，以此类推……然后当我们点击的时候我们就可以根据
    这个selectedState来判断点击的是哪个。然后进行相应的查询或者联网操作。

    然后就是我们拿到相应的数据之后，添加到一个列表上面，然后更新ui，然后注意，在分支线程当中是不能更新ui的，因此我们此时是利用Handler发送出消息
    给主线程，然后在handlerMessage方法里面进行ui的更新。

功能1.3 ---- 需要在每个列表的上面告知用户这些省份是属于哪个国家，城市是属于哪个省份，县级是属于哪个城市的
    那么此时这个可以拉出来的页面就不能单单有recyclerView了，还需有一个TextView用来显示下面的省市县是属于哪里的。但是此处有一个问题产生了，就是我们
    是通过recyclerView的点击事件才知道这个TextView是要展示生命内容，那么也就是说需要在recyclerView的点击事件里面更新ui或者HandleMessage方法中更新
    ui，但是一个很大的问题就是，在recyclerView中我们是无法获取到这个TextView的实例的。也就是无法调用findViewById的。这个方法是只有activity才有的！
    因此此时有两种选择，1.就是把这个recyclerView当作内部类嵌套在活动里面，这样我们可以利用活动实例findViewById。2.我们可以利用fragment，在fragment
    当中可以找到与之相关联的activity（但是要注意是在碎片生命周期中的onActivityCreated周期及之后活动才创建出来，我们才可以找到活动）。

    因此为了不让MainActivity中的代码太冗杂，我采取了2的方法。将recyclerView嵌套在fragment里面，然后在碎片的onActivityCreate方法中我们找到与之对应的
    activity实例对象，然后设置为实例变量，这样在点击事件当中就可以用这个变量来findViewById()了。那么这里就需要进行一些fragment的初始化操作了。

    到这里其实之前的初始化省份的代码也可以移到碎片这里来，不用写到activity当中了，也可以一并写到碎片的onActivityCreate方法当中的。这里也体现了碎片的强大，
    和activity的地位有的一比。

功能1.4 --- 需要可以返回到上一级目录当中
    那么就是需要点击某个按钮，然后返回到上一级目录当中，这里就是添加一个按钮的点击操作，然后根据当前列表所处的级别来进行相关的操作，如果是省份级别，那么
    就是直接将这个drawer收回了，如果是城市级别，那么就返回到Province，以此类推；这里我们是通过获取TextView上面的名称，然后在数据库当中重新查找的方式来的
    这样其实感觉效率有些低而且代码冗杂，其实效率也不低，因为数据少，查找快。不知道还有没有别的方法。

    这里其实和正着找差不多，但是这个更简单一些，因为数据都是从数据库里面取出来就好了，不需要通过联网。

    这里我们将这些代码放在了MainActivity当中，其实放在fragment当中也是可以的。因为可能在实际开发中MainActivity更多是处理别的逻辑了。

功能2：--- 点击县级数据，获取到天气数据展示出来，利用到GSON解析方式

功能2.1 ---
    ui部分：这里主要获取到的数据就是要展示到activity_main.xml文件的第一个布局上面，我们采用的是material design的涉及方式。也就是第12章的跳转页面那里的知识。
    先用一个CoordinateLayout布局，然后嵌套AppBarLayout布局，然后嵌套……………………最重要的就是给相关要赋值的控件设置好id，便于直接写，这里有一个技巧就是自己
    先在上面写，然后到时候在来对应也可以的。然后注意ToolBar的使用，需要调用setSupportActionBar,不然会有很大的问题！编写的时候这里弄了很久。

    代码部分：就是点击然后发送请求，然后解析，这里的主要知识点着眼于解析json文件，这里使用的是GSON解析，为什么呢？因为GSON是用面向对象的思想来的，而这里返回的都是
    一个一个的，符合GSON中的解析样式，就是只有一个对象的那种，然后这里就是对象中还有多个对象，或者这个对象中是列表或者字符串这样，
    记住原则：一个大的 { } 就是一个对象 ，对象里面可能还有对象或者其它数据类型这样。引号引起来的就是这个对象的属性，注意这个对象的名字是我们自己取的，属性名不能
    随便取，需要和返回的数据中一一对照。

    比如：
    {"name":"Tom","age":20}----->那么这里可以将这个括号定义为一个Student对象，然后拥有name和age属性，name属性对应的是String类型，age属性对应的是int类型。
    当然也可以还有比如{"name":"Tom","age":20,"address":{"city":"ShenZhen"}}这样，那么它就拥有多一个属性address，是一个对象来的，这个对象里面有city属性，这里就回忆起学java时候的难了，哈哈。
    挺难的，需要慢慢来。

    然后将获取到的数据就开始进行解析了，然后注意解析过程中我们也是顺便直接将解析出来的数据赋值给ui中对应的了。这里解析我们放在了util工具类当中，需要
    传入需要解析的数据和一个activity对象（用于找控件）

    对了然后这里需要注意，必须在联网之前检查是否有网，有网才连接，没网就需要提示用户打开网络才能连接。


功能3：---- 用户在由没有打开到打开的时候，需要自动更新ui
    这里就是简单的通过SharedPreference来实现的，我们在用户每次退出这个程序的时候将最后访问的天气地址收到preference里面，然后程序初始化的时候拿到然后进行访问。
    因此这里肯定是要将weather的url设置为实例（全局）变量的，而不是局部变量的。


功能4 ---- 在程序在后台的时候按时更新
    这里遇到最大的坑就是没有注册，然后居然还不报错！！！！刚开始为了拿到activity和weather_address实例变量，将这个服务设置为内部类
    但是发现非常难注册，要注册就要直接将它设置为public static class ……（可能这样才可以使这个类被发现吧，然后才能注册）
    而这样就会报如下错误：
    Non-static field 'weather_address' cannot be referenced from a static context
    其实也好解释，当一个类是public static class 的时候，其实也就意味着这个类是一个独立的类，应该也不算是什么内部类了，
    因此自然不能就是用其它类中的成员变量了，如果要使用其它类中的变量，也必须只能是静态变量！！

    这里非常需要回顾变量的区别和作用：变量分为成员变量和局部变量，成员变量中又有静态变量和实例变量；静态变量是类级别的变量，而
    成员变量是对象级别的变量；实例变量不能用在静态方法当中，因为静态方法是由类来调用的，而实例变量必须由对象来调用，因此不行。
    而静态变量是可以用在实例方法中的，可以被正常赋值，当然也可以用在静态方法和其它类中，这点很重要。静态变量存储在方法区当中，
    在类加载的时候就有了，比较消耗内存；而实例变量存储在堆区当中，和对象共存亡；在此过程中静态变量虽然耗内存，但是起了非常大的作用！

    言归正传，这里启动定时服务就是创建一个服务，然后开启定时任务，并且当这个app不在后台时不用更新；这个任务只需要我们手动启动一次
    后面的就由它自己启动了---。然后最重要的时intent对象里面存放的weather_address，在服务的onStartCommand(Intent intent,int flags,……)
    方法执行的时候我们需要拿到这个intent里面的内容，以及我们每次都要存放进最新的weather_address---->这个就是通过使用静态变量来控制了。

功能5：
    刷新的逻辑--第一次下载app然后刷新，肯定是没有weather_address的。
    只有在第一次访问完之后才会有的，并且就是长期有了，因为是存储在sharedPreference当中了
    注意：对于刷新ui，这个ui就是到顶了，然后下拉就会进行刷新了---需要记住这个原则
    然后注意这里采用的是material design的设计，注意布局之间的关系，CoordinatorLayout是FrameLayout布局，AppBarLayout是垂直布局
    一般我们需要将后面的和这个AppbarLayout相适应，也就是设置app:layout_behavior="@string/appbar_scrolling_view_behavior"属性


暂未完成的事项：
1、功能5刷新操作
2、需要考虑用户在第一次下载这个软件时然后初始化失败怎么处理，比如初始化省份列表就失败了---那么应该提供刷新功能重新获取省份数据



感悟：
1、思路就是跟着ui走的，所以需要先有demo，然后根据demo来一个功能一个功能编写.
2、遇到忘记了的知识点就需要回顾一下，当复习，弄透来，这样才是进步。
3、需要非常注重代码的执行顺序，这个通过log来手动执行
4、非常需要关注对象的生命周期，什么时候被创建，什么时候被销毁。然后里面的变量的生命周期随之会怎么样。


编写注意事项：
1、养成一边写一边测试的好习惯，写一点测一点，改一点测一点。或者不确定的时候创建多一个新的app进行试验。
2、学会使用logt，利用这个来手动执行，这样我们就知道我们写的一些代码是否有运行。



